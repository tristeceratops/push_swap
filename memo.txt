ON REPART DE 0

créer des cas spécifiques pour petits jeux de données (2 - 3 - 4 et 5)

LIS ALGO:
Longest Increasing Subsequences ou Plus Grande sous séquences croissantes
Calculer la LIS et la garder dans A, le reste est déplacé dans B

ensuite pour chaque valeurs dans B, calculer deux valeurs :
-Le nombre de déplacement pour accéder à TOP B (valeur -négative quand on doit utiliser reverse rotation) (MA)
-et le nombre de rotation qu'il faut faire dans A pour pouvoir le placer au bon endroit (MB)

à chaque itération de la boucle, on recalcules ces deux valeurs et on déplace de B à A le nombre qui créera le moins de mouvement
	|	mov_b +		|	mov_b -
--------|-----------------------|-----------------------
mov_a +	|   max(mov_a, mov_b)	|   mov_a + |mov_b|
--------|-----------------------|-----------------------
mov_a -	|  |mov_a| + mov_b	|  |min(mov_a, mov_b)|

https://github.com/sisittu99/push_swap/blob/master/README_EN.md#choosing-the-best-number

Génération de la LIS sous forme de t_list
(récursivité ???) (proche du ten queens puzzle ???)
générée récursivement la première LIS qu'on gardera et qu'on comparera à la prochaine où on gardera la plus grande

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <limits.h>

typedef struct s_list
{
	void			*content;
	struct s_list	*next;
}	t_list;

typedef struct s_stack
{
	t_list	*top;
}	t_stack;

int	ft_lstsize(t_list *lst)
{
	int	size;

	size = 0;
	while (lst != NULL)
	{
		lst = lst->next;
		size++;
	}
	return (size);
}

int get_max(t_list* list) {
    int max_value = INT_MIN;

    while (list != NULL) {
        if ((int)(intptr_t)list->content > max_value) {
            max_value = (int)(intptr_t)list->content;
        }
        list = list->next;
    }

    return max_value;
}

int get_min(t_list* list) {
    int min_value = INT_MAX;

    while (list != NULL) {
        if ((int)(intptr_t)list->content < min_value) {
            min_value = (int)(intptr_t)list->content;
        }
        list = list->next;
    }

    return min_value;
}

void push(t_stack* stack, int value) {
    // Create a new node
    t_list* new_node = (t_list*)malloc(sizeof(t_list));
    if (!new_node) {
        fprintf(stderr, "Failed to allocate memory for new node.\n");
        return;
    }

    // Set the new node's value
    new_node->content = (void*)(intptr_t)value;

    // Push the new node onto the stack
    new_node->next = stack->top;
    stack->top = new_node;
}

int mov_a_index_calc(int k, t_stack *stack_a)
{
    int size;
    
    size = ft_lstsize(stack_a->top);
    if (k > size /2)
    {
        k = 2;
    }
}

int get_index(t_list* list, int value) {
    int index = 0;

    while (list != NULL) {
        if ((int)(intptr_t)list->content == value) {
            return index;
        }
        index++;
        list = list->next;
    }

    return -1; // Value not found
}

int* get_mov_a(t_stack* stack_a, t_stack* stack_b) {
    int size_b = ft_lstsize(stack_b->top);
    int* mov_a = (int*)malloc(size_b * sizeof(int));
    t_list *temp_a = stack_a -> top;
    if (!mov_a)
        return NULL;
    int i = 0;
    int j = 0;
    int min = get_max(temp_a);
    while (stack_b->top != NULL)
    {
        j = 0;
        temp_a = stack_a -> top;
        while (temp_a->next != NULL)
        {
            if ((int)(intptr_t)temp_a->content < (int)(intptr_t)stack_b->top->content)
            {
                if ((int)(intptr_t)stack_b->top->content < (int)(intptr_t)temp_a->next->content)
                {
                    mov_a[i] = j;
                    break ;
                }
            }
            j++;
            temp_a = temp_a->next;
        }
        if (temp_a->next == NULL)
        {
            mov_a[i] = get_index(stack_a->top, get_max(stack_a->top));
        }
        i++;
        stack_b->top =stack_b->top->next;
    }
    return mov_a;
}

int main() {
    t_stack stack_a;
    t_stack stack_b;

    // Initialize stack_a and stack_b here
    stack_a.top = NULL; // Assuming t_stack has a top member pointing to the top of the stack
    stack_b.top = NULL; // Same assumption for stack_b

    // Assuming you have a function to push elements onto the stack
    // For example, let's push some elements onto stack_a and stack_b
    // Assuming push function is defined elsewhere
    push(&stack_a, 1);
    push(&stack_a, 4);
    push(&stack_a, 7);

    push(&stack_b, -4);
    push(&stack_b, 10);
    push(&stack_b, 8);
    push(&stack_b, 5);
    push(&stack_b, 3);
    push(&stack_b, 2);
    push(&stack_b, -2);

    int* mov_a = get_mov_a(&stack_a, &stack_b);

    // Print the mov_a array
    for (int i = 0; i < ft_lstsize(stack_b.top); i++) {
        printf("%d ", mov_a[i]);
    }

    free(mov_a);

    return 0;
}

créer mov_a
stack_a		stack_b
1				0
4				2
7				5
				8
mov_a = 0 1 2 -1