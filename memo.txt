ON REPART DE 0

créer des cas spécifiques pour petits jeux de données (2 - 3 - 4 et 5)

LIS ALGO:
Longest Increasing Subsequences ou Plus Grande sous séquences croissantes
Calculer la LIS et la garder dans A, le reste est déplacé dans B

ensuite pour chaque valeurs dans B, calculer deux valeurs :
-Le nombre de déplacement pour accéder à TOP B (valeur -négative quand on doit utiliser reverse rotation) (MA)
-et le nombre de rotation qu'il faut faire dans A pour pouvoir le placer au bon endroit (MB)

à chaque itération de la boucle, on recalcules ces deux valeurs et on déplace de B à A le nombre qui créera le moins de mouvement
	|	mov_b +		|	mov_b -
--------|-----------------------|-----------------------
mov_a +	|   max(mov_a, mov_b)	|   mov_a + |mov_b|
--------|-----------------------|-----------------------
mov_a -	|  |mov_a| + mov_b	|  |min(mov_a, mov_b)|

https://github.com/sisittu99/push_swap/blob/master/README_EN.md#choosing-the-best-number

Génération de la LIS sous forme de t_list
(récursivité ???) (proche du ten queens puzzle ???)
générée récursivement la première LIS qu'on gardera et qu'on comparera à la prochaine où on gardera la plus grande

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

typedef struct s_list {
    struct s_list *next;
    void *content;
} t_list;

typedef struct s_lis_wrap
{
        int     maxlen;
        int     maxindex;
        int     *arr;
        int     *lis;
        int     *prev;
}       t_lis_wrap;

void	convert_list_to_array(t_list *head, int *arr, int *length)
{
	t_list	*current;
	int	i;

	current = head;
	i = 0;
	while (current != NULL && i < *length)
	{
		arr[i++] = (int)(intptr_t)current->content;
		current = current->next;
	}
}

int     ft_lstsize(t_list *lst)
{
        int     size;

        size = 0;
        while (lst != NULL)
        {
                lst = lst->next;
                size++;
        }
        return (size);
}

void    ft_lstadd_back(t_list **lst, t_list *new)
{
        t_list  *last;

        if (*lst == NULL)
                *lst = new;
        else
        {
                last = *lst;
                while (last->next != NULL)
                {
                        last = last->next;
                }
                last->next = new;
        }
}

t_list  *ft_lstnew(void *content)
{
        t_list  *node;

        node = malloc(sizeof(*node));
        node -> content = content;
        node -> next = NULL;
        return (node);
}


void    construct_lis(t_lis_wrap *lis_wrap, int length)
{
        int     i;
        int     j;

        i = 0;
        while (i < length)
        {
                lis_wrap->lis[i] = 1;
                lis_wrap->prev[i] = -1;
                j = 0;
                while (j < i)
                {
                        if (lis_wrap->arr[j] < lis_wrap->arr[i] && lis_wrap->lis[j] + 1 > lis_wrap->lis[i])
                        {
                                lis_wrap->lis[i] = lis_wrap->lis[j] + 1;
                                lis_wrap->prev[i] = j;
                        }
                        j++;
                }
                if (lis_wrap->lis[i] > lis_wrap->maxlen)
                {
                        lis_wrap->maxlen = lis_wrap->lis[i];
                        lis_wrap->maxindex = i;
                }
                i++;
        }
}

int     *construct_result(t_lis_wrap *lis_wrap)
{
        int     *result;
        int     index;

        result = (int *)malloc(lis_wrap->maxlen *sizeof(int));
        if (!result)
                return (NULL);
        index = lis_wrap->maxlen - 1;
        while (lis_wrap->maxindex >= 0)
        {
                result[index] = lis_wrap->arr[lis_wrap->maxindex];
                index--;
                lis_wrap->maxindex = lis_wrap->prev[lis_wrap->maxindex];
        }
        return (result);
}



int     *LIS(t_list *head, int *length)
{
        t_lis_wrap      lis_wrap;
        int             *result;

        lis_wrap.arr = (int *)malloc(*length * sizeof(int)); //original list convert in array
        lis_wrap.lis = (int *)malloc(*length * sizeof(int)); //size of LIS
        lis_wrap.prev = (int *)malloc(*length * sizeof(int)); //previous index
        lis_wrap.maxlen = 1;
        lis_wrap.maxindex = 0;
        if (lis_wrap.arr == NULL || lis_wrap.lis == NULL || lis_wrap.prev == NULL)
                exit(EXIT_FAILURE);
        convert_list_to_array(head, lis_wrap.arr, length);
        construct_lis(&lis_wrap, *length);
        *length = lis_wrap.maxlen;
        result = construct_result(&lis_wrap);
        if(!result)
                return (NULL);
        return (result);
}




int main() {
    t_list* head = NULL;
    ft_lstadd_back(&head, ft_lstnew(((void *)(intptr_t)2)));
    ft_lstadd_back(&head, ft_lstnew((void *)(intptr_t)12));
    ft_lstadd_back(&head, ft_lstnew((void *)(intptr_t)7));
    ft_lstadd_back(&head, ft_lstnew((void *)(intptr_t)29));
    ft_lstadd_back(&head, ft_lstnew((void *)(intptr_t)18));
    ft_lstadd_back(&head, ft_lstnew((void *)(intptr_t)14));
    ft_lstadd_back(&head, ft_lstnew((void *)(intptr_t)16));

    int length = ft_lstsize(head);
    int* lis = LIS(head, &length);

    printf("Longest Increasing Subsequence: ");
    for (int i = 0; i < length; i++) {
        printf("%d ", lis[i]);
    }
    printf("\n");

    // Free allocated memory
    free(lis);
    
    return 0;
}
